Chalo, main tumhe **Alien Dictionary** problem ka pura logic Hinglish me step-by-step samjhata hoon.
Isme hum basically **graph banayenge** aur **topological sort** karenge.

---

## **Logic**

Yeh problem ka simple matlab hai:
Hume words ka ek list diya gaya hai jo alien language ke hisaab se sorted hai.
Hume **characters ka order** nikalna hai jo iss sorting rule ko follow kare.

Ye kaam hum **Directed Graph** aur **Topological Sort** ka use karke karenge.

---

## **Steps**

### **Step 1: Graph Banana**

1. Har consecutive words ka pair compare karo.
2. Jo **pehla character** different mile usse ordering milta hai.

   * Example: `"baa"` aur `"abcd"` → pehla difference `'b'` vs `'a'` → iska matlab **'b' a ke pehle aata hai** → ek edge ban gaya: `b → a`.
3. Agar dono words same shuru ho rahe hain, lekin pehla word lamba hai (jaise `"abc"` aur `"ab"`), toh yeh **invalid case** hai → return `""`.

---

### **Step 2: Topological Sort (Kahn’s Algorithm)**

1. Har node (character) ka `indegree` count karo (kitne edges us par aa rahe hain).
2. Jinka `indegree = 0` hai unko queue me daalo.
3. Jab tak queue empty na ho:

   * Ek character nikaalo → result me add karo.
   * Uske saare neighbours ka `indegree` 1 kam karo.
   * Jiska `indegree` 0 ho jaaye → queue me daalo.

---

### **Step 3: Invalid Case Detect Karna**

* Agar topological sort ka result ka size `< total characters` hai → iska matlab **cycle hai** → return `""`.
* Agar prefix violation mil gaya toh pehle hi return `""`.

---

### **Step 4: Answer Return Karna**

* Topological order ke characters ko string me convert karo aur return karo.

---

## **Dry Run Example**

Words:
`["baa", "abcd", "abca", "cab", "cad"]`
`K = 4`

**Graph banana:**

1. `"baa"` vs `"abcd"` → `'b'` → `'a'`
2. `"abcd"` vs `"abca"` → `'d'` → `'a'`
3. `"abca"` vs `"cab"` → `'a'` → `'c'`
4. `"cab"` vs `"cad"` → `'b'` → `'d'`

Graph:

```
b → a
b → d
d → a
a → c
```

---

**Topological Sort:**

* Indegree:

  ```
  a: 2  (from b, d)
  b: 0
  c: 1  (from a)
  d: 1  (from b)
  ```

Queue: `[b]`

Processing:

1. Pop `b` → order: `b` → `a(1)`, `d(0)` → push `d`
2. Pop `d` → order: `b, d` → `a(0)` → push `a`
3. Pop `a` → order: `b, d, a` → `c(0)` → push `c`
4. Pop `c` → order: `b, d, a, c`

Answer: `"bdac"`

---

Agar tum chaho to main iska **flowchart-type pseudo code** bana ke de sakta hoon, jisme tum easily dekh paoge ki kis step ke baad kaunsa step aata hai.
Kya main wo bana du?
/////////////////////////////////////////////////////


Flow of Execution (Diagram in Words)
Start

Compare word[i] and word[i+1]

Find first different character

Agar mila → edge banado

Agar nahi mila aur pehla word bada hai → Invalid → return ""

Jab saare words compare ho jaaye → graph ready

Indegree calculate karo

Queue me daalo saare nodes jinka indegree = 0

BFS chalao:

Node nikaalo → result me add karo → neighbours ka indegree kam karo → jo zero ho gaya queue me daalo

Agar result ka size < K → Cycle → return ""

Nahi toh result ko string me convert karo aur return karo

End//////////////////////////////////////

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> topoSort(int k, vector<int> adj[]) {
        vector<int> indegree(k, 0); // FIX: size initialized

        for (int i = 0; i < k; i++) {
            for (auto &neigh : adj[i]) {
                indegree[neigh]++;
            }
        }

        queue<int> q;
        for (int i = 0; i < k; i++) {
            if (indegree[i] == 0) {
                q.push(i); // FIX: push node index
            }
        }

        vector<int> topoArr;
        while (!q.empty()) {
            int f = q.front();
            q.pop();
            topoArr.push_back(f);

            for (auto &neigh : adj[f]) {
                indegree[neigh]--;
                if (indegree[neigh] == 0) {
                    q.push(neigh);
                }
            }
        }
        return topoArr;
    }

    string findOrder(vector<string> &words) {
        unordered_set<int> unique;
        for (auto &w : words) {
            for (char ch : w) {
                unique.insert(ch - 'a'); // store index not char
            }
        }

        vector<int> adj[26]; // full alphabet graph

        int n = words.size();
        for (int i = 0; i < n - 1; i++) {
            string &s1 = words[i];
            string &s2 = words[i + 1];

            // prefix check
            if (s1.size() > s2.size() && s1.substr(0, s2.size()) == s2) return "";

            int len = min(s1.size(), s2.size());
            for (int j = 0; j < len; j++) {
                if (s1[j] != s2[j]) {
                    adj[s1[j] - 'a'].push_back(s2[j] - 'a');
                    break; // only first diff matters
                }
            }
        }

        vector<int> topo = topoSort(26, adj);

        string topoOrder;
        for (int node : topo) {
            if (unique.count(node)) {  // jo char sr main hai wahi liya hai
                topoOrder += char(node + 'a');
            }
        }

        // final cycle check
        if (topoOrder.size() < unique.size()) return "";

        return topoOrder;
    }
};
